############################################
#      Ventilation increase on CO2         #
#   (level or derivative, multi-sensor)    #
#  Version: 1.0                            #
#  Date: 2025-10-11                        #
#  Author: Mikko Jylhä                     #
############################################

############################################
#         CO2 SENSOR LISTS (EDIT HERE)     #
############################################
# Define all your CO2 sensors once here; the automation below will use them.
# Add/remove sensors freely; the automation picks up changes automatically.
group:
  co2_sensors:
    name: "CO2 Sensors"
    entities:
      - sensor.measure_thcnp_room1_co2
      - sensor.measure_thc_room2_co2
      - sensor.measure_thc_room3_co2
      - sensor.measure_thc_room4_co2

  co2_derivative_sensors:
    name: "CO2 Derivative Sensors"
    entities:
      - sensor.deriv_room1_co2
      - sensor.deriv_room2_co2
      - sensor.deriv_room3_co2
      - sensor.deriv_room4_co2

############################################
#                 HELPERS                  #
############################################
# Reuses existing action helpers:
#  - input_select.method_ventilation_increase
#  - input_number.steps_to_increase
#  - input_number.delay_reverse_seconds
#  - input_number.timeout_monitor_seconds
# And relay switches in secrets.yaml:
#  - boost_switch_b, plus_switch_b, minus_switch_b

input_select:
  co2_trigger_mode:
    name: "CO2 Trigger Mode"
    options:
      - level
      - derivative
      - level_and_derivative
    icon: mdi:molecule-co2

input_number:
  co2_level_threshold_ppm:
    name: "CO2 Level Threshold (ppm)"
    min: 400
    max: 3000
    step: 25
    mode: box
    icon: mdi:gauge
    initial: 900

  co2_derivative_threshold_ppm_min:
    name: "CO2 Derivative Threshold (ppm/min)"
    min: 0
    max: 200
    step: 10
    mode: box
    icon: mdi:chart-bell-curve-cumulative
    initial: 100

  co2_drop_threshold_ppm:
    name: "CO2 Drop Threshold (ppm)"
    min: 400
    max: 3000
    step: 25
    mode: box
    icon: mdi:gauge
    initial: 800

############################################
#                AUTOMATION                #
############################################

automation:
  - id: co2_ventilation_increase
    alias: "Ventilation: Increase on CO2 Level/Derivative"
    mode: restart
    description: >
      Triggers when CO2 level/derivative exceeds threshold on ANY sensor in groups:
      group.co2_sensors (levels) and group.co2_derivative_sensors (derivatives).
      Methods: single_service, pulse_then_wait_then_reverse, pulse_until_below.

    trigger:
      - platform: template
        value_template: >-
          {% set mode = states('input_select.co2_trigger_mode') %}
          {% set thr_l = states('input_number.co2_level_threshold_ppm')|float(0) %}
          {% set thr_d = states('input_number.co2_derivative_threshold_ppm_min')|float(0) %}

          {# Expand groups into lists of entities (may be empty if not defined) #}
          {% set levels = expand('group.co2_sensors') or [] %}
          {% set derivs = expand('group.co2_derivative_sensors') or [] %}

          {# Build simple maps of entity_id -> numeric value for ease of access #}
          {% set level_map = dict( (e.entity_id, e.state|float(0)) for e in levels ) %}
          {% set deriv_map = dict( (d.entity_id, d.state|float(0)) for d in derivs ) %}

          {# Quick ANY checks for the chosen mode #}
          {% set ns = namespace(hit=false) %}

          {% if mode == 'level' %}
            {% for (id, val) in level_map.items() %}
              {% if val >= thr_l %}{% set ns.hit = true %}{% endif %}
            {% endfor %}

          {% elif mode == 'derivative' %}
            {% for (id, dval) in deriv_map.items() %}
              {% if dval > thr_d %}{% set ns.hit = true %}{% endif %}
            {% endfor %}

          {% elif mode == 'level_and_derivative' %}
            {# Require both for at least one "room".
               Heuristic pairing: expect derivative ids to be 'sensor.deriv_' + base id (after 'sensor.').
               If your naming differs, you can add a proper mapping here. #}
            {% for (id, val) in level_map.items() %}
              {% set candidate = 'sensor.deriv_' ~ id.split('.', 1)[1] %}
              {% set dval = deriv_map.get(candidate, none) %}
              {% if dval is not none and (val >= thr_l) and (dval > thr_d) %}
                {% set ns.hit = true %}
              {% endif %}
            {% endfor %}
          {% endif %}

          {{ ns.hit }}
        for: "00:00:30"

    variables:
      method_v: "{{ states('input_select.method_ventilation_increase') }}"
      steps_increase: "{{ states('input_number.steps_to_increase')|int(0) }}"
      delay_reverse: "{{ states('input_number.delay_reverse_seconds')|int(0) }}"
      co2_drop: "{{ states('input_number.co2_drop_threshold_ppm')|float(0) }}"
      timeout_monitor: "{{ states('input_number.timeout_monitor_seconds')|int(0) }}"
      mode_v: "{{ states('input_select.co2_trigger_mode') }}"

      # Switch entities from secrets.yaml (same secrets you already use)
      boost_switch_b: !secret boost_switch_b
      plus_switch_b: !secret plus_switch_b
      minus_switch_b: !secret minus_switch_b

    action:
      - choose:
          # METHOD 1: Boost (single_service)
          - conditions:
              - condition: template
                value_template: "{{ method_v == 'single_service' }}"
            sequence:
              - service: switch.turn_on
                target:
                  entity_id: "{{ boost_switch_b }}"
              - service: system_log.write
                data:
                  level: info
                  message: "CO2: single_service → Boost pressed once (mode={{ mode_v }})."

          # METHOD 2: pulse_then_wait_then_reverse
          - conditions:
              - condition: template
                value_template: "{{ method_v == 'pulse_then_wait_then_reverse' }}"
            sequence:
              - service: system_log.write
                data:
                  level: info
                  message: "CO2: pulse_then_wait_then_reverse → up {{ steps_increase }}, wait {{ delay_reverse }}s, then down."
              - repeat:
                  count: "{{ steps_increase }}"
                  sequence:
                    - service: switch.turn_on
                      target:
                        entity_id: "{{ plus_switch_b }}"
                    - delay: "00:00:01"
              - delay:
                  seconds: "{{ delay_reverse }}"
              - repeat:
                  count: "{{ steps_increase }}"
                  sequence:
                    - service: switch.turn_on
                      target:
                        entity_id: "{{ minus_switch_b }}"
                    - delay: "00:00:01"
              - service: system_log.write
                data:
                  level: info
                  message: "CO2: reverse sequence complete."

          # METHOD 3: pulse_until_below
          - conditions:
              - condition: template
                value_template: "{{ method_v == 'pulse_until_below' }}"
            sequence:
              - service: system_log.write
                data:
                  level: info
                  message: "CO2: pulse_until_below → up {{ steps_increase }}, then monitor until any CO2 < {{ co2_drop }} ppm."
              - repeat:
                  count: "{{ steps_increase }}"
                  sequence:
                    - service: switch.turn_on
                      target:
                        entity_id: "{{ plus_switch_b }}"
                    - delay: "00:00:01"
              - wait_for_trigger:
                  - platform: template
                    value_template: >-
                      {% set levels = expand('group.co2_sensors') or [] %}
                      {% set ns = namespace(done=false) %}
                      {% for e in levels %}
                        {% if e.state|float(0) < co2_drop %}
                          {% set ns.done = true %}
                        {% endif %}
                      {% endfor %}
                      {{ ns.done }}
                timeout: >-
                  {% if timeout_monitor|int(0) > 0 %}{{ timeout_monitor|int(0) }}{% else %}0{% endif %}
                continue_on_timeout: true
              - service: system_log.write
                data:
                  level: info
                  message: "CO2: condition cleared or timeout → step down {{ steps_increase }}."
              - repeat:
                  count: "{{ steps_increase }}"
                  sequence:
                    - service: switch.turn_on
                      target:
                        entity_id: "{{ minus_switch_b }}"
                    - delay: "00:00:01"
              - service: system_log.write
                data:
                  level: info
                  message: "CO2: pulse_until_below complete."

        default: []
